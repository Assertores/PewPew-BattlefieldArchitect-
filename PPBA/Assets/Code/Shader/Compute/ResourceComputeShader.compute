// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSInit
#pragma kernel CSMain
#pragma kernel CSTerritorium

int PointSize;
float4 coords[50];
int SoldiersSize;
float4 Soldiers[50];

const float3 team1 = float3(1,0,0);
const float3 team2 = float3(0,1,0);
const float3 team3 = float3(0,0,1);
const float3 team4 = float3(1,1,0);

RWStructuredBuffer<int> buffer;
RWTexture2D<float4> Result;
RWTexture2D<float4> TerritoriumResult;
Texture2D<float4> InputTexture;


[numthreads(1, 1, 1)] 
void CSInit(uint3 id : SV_DispatchThreadID)
{
	for (int i = 0; i < 50; i++)
	{
		buffer[i] = 0;
	}

}

[numthreads(8, 8, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
	for (int i = 0; i < PointSize; i++)
	{
		float dis = distance(float2(id.x, id.y), float2(coords[i].x, coords[i].y));

		if (dis > coords[i].w)
		{
			continue;
		}

		float maxDis = coords[i].w;
		//float distfactor = 1 - (dis / maxDis);
		//distfactor = sqrt(distfactor * 2);
		float harvestFac = smoothstep(maxDis, 0.0, dis) * coords[i].z;// distfactor * coords[i].z;


		float4 curCol = InputTexture[id.xy].rgba;
		
		float minValue = float(min(curCol.r, harvestFac));
		float newCol = curCol.r - minValue;
	
		//	float3 col = lerp(curCol.rgb, newCol, t);
		newCol = saturate(newCol);

		InterlockedAdd(buffer[i], minValue * 1000000.0);
		Result[id.xy] = float4(newCol.rrr, curCol.a);
	}
}

[numthreads(8, 8, 1)]
void CSTerritorium(uint3 id : SV_DispatchThreadID)
{
	for (int i = 0; i < SoldiersSize; i++)
	{
		float dis = distance(float2(id.x, id.y), float2(Soldiers[i].x, Soldiers[i].y));

		if (dis > 50)
		{
			continue;
		}

		for (int y = 0; y < SoldiersSize; y++)
		{
			float disToSoldiers = distance(float2(Soldiers[y].x, Soldiers[y].y), float2(Soldiers[i].x, Soldiers[i].y));

			if(disToSoldiers < disToSoldiers * 0.5)
			{

			}
		}

		TerritoriumResult[id.xy] = float4(float3(0.0,0.0,1.0), 1.0);
	}
}