// Each #kernel tells which function to compile; you can have many kernels

#pragma kernel CSInit
#pragma kernel CSMain
#pragma kernel CSTerritorium
#pragma kernel CSNextEdge

int PointSize;
const int weightMap = 512;
float4 coords[50];
int SoldiersSize;
float4 Soldiers[50];
int stateSize;
float2 state[50];

RWStructuredBuffer<int> buffer;
RWStructuredBuffer<uint> bitField;

RWTexture2D<float4> Result;
RWTexture2D<float4> TerritoriumResult;
//Texture2D<float4> InputTexture;


[numthreads(1, 1, 1)]
void CSInit(uint3 id : SV_DispatchThreadID)
{
	for (int i = 0; i < 50; i++)
	{
		buffer[i] = 0;

	}
}

[numthreads(8, 8, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{

	float currentResources = Result[id.xy].r;

	for (int i = 0; i < PointSize; i++)
	{
		float dis = distance(float2(id.x, id.y), float2(coords[i].x, coords[i].y));

		float maxDis = coords[i].w;

		if (dis > maxDis)
		{
			continue;
		}

		float harvestFac = smoothstep(maxDis, 0.0, dis) * coords[i].z; // distfactor * coords[i].z;

		//float4 curCol = InputTexture[id.xy].rgba;

		//float minValue = float(min(curCol.r, harvestFac));
		float minValue = float(min(currentResources, harvestFac));

		//float newCol = curCol.r - minValue;
		currentResources -= minValue;

		//	float3 col = lerp(curCol.rgb, newCol, t);
		//newCol = saturate(newCol);
		currentResources = saturate(currentResources);

		InterlockedAdd(buffer[i], minValue * 1000000.0);
		/*
		if (Result[id.xy] != float4(newCol.rrr, curCol.a))
		{
			int myIndex;
			InterlockedAdd(resourcesIndex, 1, myIndex);
			resourcesChanged[myIndex] = id.x;

			Result[id.xy] = float4(newCol.rrr, curCol.a);
		}*/
	}

	
	if (Result[id.xy].r != currentResources)
	{
		int bit = id.y * weightMap + id.x;
		InterlockedAdd(bitField[bit / (8 * 4)], 1 << (bit % (8 * 4)));

		Result[id.xy] = float4(currentResources, 0.0, 0.0, 1.0);
	}
}


[numthreads(8, 8, 1)]
void CSTerritorium(uint3 id : SV_DispatchThreadID)
{
	float m_dist = 10; // minimun distance
	float2 m_point; // minimum position

	// Iterate through the points positions
	for (int i = 0; i < SoldiersSize; i++)
	{
		float dist = distance(id.xy, Soldiers[i].xy);

		if (dist > m_dist)
			continue;

		if (dist < m_dist)
		{
			// Keep the closer distance
			m_dist = dist;

			// Kepp the position of the closer point
			m_point = Soldiers[i].xy;
		}

		if (Soldiers[i].z == 0)
		{
			m_point = float3(1, 0, 0);
		}
		if (Soldiers[i].z == 1)
		{
			m_point = float3(2, 0, 0);
		}
		if (Soldiers[i].z == 2)
		{
			m_point = float3(3, 0, 0);
		}
		if (Soldiers[i].z == 3)
		{
			m_point = float3(4, 0, 0);
		}

		if (TerritoriumResult[id.xy].r != m_point.r)
		{
			int bit = id.y * weightMap + id.x;
			InterlockedAdd(bitField[bit / (8 * 4)], 1 << (bit % (8 * 4)));

			TerritoriumResult[id.xy] = float4(m_point, 0, 1);
		}
	}
}




[numthreads(8, 8, 1)]
void CSNextEdge(uint3 id : SV_DispatchThreadID)
{
	//===== ===== relevance test ===== =====
	bool imIn = false;
	for (int q = 0; !imIn || q < SoldiersSize; q++)
	{
		if (id.x == Soldiers[q].x || id.y == Soldiers[q].y)
			imIn = true;
	}
	if (!imIn)
		return;

	//===== ===== init ===== =====
	float myTeam = TerritoriumResult[id.xy].x;
	float2 found;

	float foundDist = 3.402823466e+38F;

	int maxIndex = 4000000;

	//===== ===== serach ===== =====
	for (int column = 1; column * column < foundDist; column++)
	{
		int rowLength = min(column, maxIndex);
		for (int row = 0; row <= rowLength; row++)
		{
			float2 pos;
			bool valueIsDifferent = false;

			pos = id.xy + float2(column, row);
			if (myTeam != TerritoriumResult[pos].r) valueIsDifferent = true;
			pos = id.xy + float2(-column, row);
			if (myTeam != TerritoriumResult[pos].r) valueIsDifferent = true;
			pos = id.xy + float2(column, -row);
			if (myTeam != TerritoriumResult[pos].r) valueIsDifferent = true;
			pos = id.xy + float2(-column, -row);
			if (myTeam != TerritoriumResult[pos].r) valueIsDifferent = true;
			pos = id.xy + float2(row, column);
			if (myTeam != TerritoriumResult[pos].r) valueIsDifferent = true;
			pos = id.xy + float2(-row, column);
			if (myTeam != TerritoriumResult[pos].r) valueIsDifferent = true;
			pos = id.xy + float2(row, -column);
			if (myTeam != TerritoriumResult[pos].r) valueIsDifferent = true;
			pos = id.xy + float2(-row, -column);
			if (myTeam != TerritoriumResult[pos].r) valueIsDifferent = true;

			if (valueIsDifferent)
			{
				int dist = column * column + row * row;
				if (foundDist > dist)
				{
					found = pos;
					maxIndex = row;
					foundDist = dist;
				}
			}
		}

		//===== ===== result ===== =====
		TerritoriumResult[id.xy] = float4(TerritoriumResult[id.xy].x, found.x, found.y, sqrt(foundDist));
	}
}
